// // main.go
// package main

// import (
// 	"context"
// 	"encoding/json"
// 	"io"
// 	"log"
// 	"mime"
// 	"net/http"
// 	"os"
// 	"path/filepath"
// 	"sort"
// 	"strings"
// 	"sync"
// 	"time"

// 	firebase "firebase.google.com/go/v4"
// 	"firebase.google.com/go/v4/auth"
// 	"google.golang.org/api/option"
// )

// //
// // ======== Models ========
// //

// type User struct {
// 	ID          string  `json:"id"`
// 	Name        string  `json:"name"`
// 	AvatarAsset *string `json:"avatarAsset,omitempty"`
// }

// type Comment struct {
// 	ID        string `json:"id"`
// 	Author    User   `json:"author"`
// 	Text      string `json:"text"`
// 	CreatedAt string `json:"createdAt"`
// }

// type Post struct {
// 	ID        string    `json:"id"`
// 	Author    User      `json:"author"`
// 	Text      string    `json:"text"`
// 	CreatedAt string    `json:"createdAt"`
// 	LikeCount int       `json:"likeCount"`
// 	LikedByMe bool      `json:"likedByMe"`
// 	Comments  []Comment `json:"comments"`
// 	Tags      []string  `json:"tags"`
// 	ImageURL  *string   `json:"imageUrl,omitempty"` // e.g. "/uploads/xxx.jpg"
// }

// // /users/:id èˆ‡ /me
// type Profile struct {
// 	ID            string  `json:"id"`
// 	Name          string  `json:"name"`
// 	Nickname      *string `json:"nickname"`
// 	AvatarURL     *string `json:"avatarUrl"`
// 	Instagram     *string `json:"instagram"`
// 	Facebook      *string `json:"facebook"`
// 	LineId        *string `json:"lineId"`
// 	ShowInstagram bool    `json:"showInstagram"`
// 	ShowFacebook  bool    `json:"showFacebook"`
// 	ShowLine      bool    `json:"showLine"`
// }

// //
// // ======== Store + Persistence ========
// //

// type Store struct {
// 	mu        sync.RWMutex
// 	posts     []Post
// 	tags      map[string][]string            // userId -> tags
// 	friends   map[string]map[string]struct{} // userId -> set(friendId)
// 	profiles  map[string]Profile             // userId -> profile
// 	postLikes map[string]map[string]struct{} // postId -> set(uid)
// }

// func nowISO() string { return time.Now().UTC().Format(time.RFC3339) }

// func ensureDir(d string) { _ = os.MkdirAll(d, 0o755) }

// func writeJSON(w http.ResponseWriter, status int, v any) {
// 	w.Header().Set("Content-Type", "application/json; charset=utf-8")
// 	w.WriteHeader(status)
// 	_ = json.NewEncoder(w).Encode(v)
// }

// func readJSONFile[T any](path string, out *T) error {
// 	b, err := os.ReadFile(path)
// 	if err != nil {
// 		return err
// 	}
// 	return json.Unmarshal(b, out)
// }

// func writeJSONFile(path string, v any) error {
// 	b, err := json.MarshalIndent(v, "", "  ")
// 	if err != nil {
// 		return err
// 	}
// 	return os.WriteFile(path, b, 0o644)
// }

// func (s *Store) loadAll(postsFile, tagsFile, friendsFile, profilesFile, likesFile string) {
// 	_ = readJSONFile(postsFile, &s.posts)
// 	if s.tags == nil {
// 		s.tags = make(map[string][]string)
// 	}
// 	if s.friends == nil {
// 		s.friends = make(map[string]map[string]struct{})
// 	}
// 	if s.profiles == nil {
// 		s.profiles = make(map[string]Profile)
// 	}
// 	if s.postLikes == nil {
// 		s.postLikes = make(map[string]map[string]struct{})
// 	}
// 	_ = readJSONFile(tagsFile, &s.tags)
// 	_ = readJSONFile(friendsFile, &s.friends)
// 	_ = readJSONFile(profilesFile, &s.profiles)
// 	_ = readJSONFile(likesFile, &s.postLikes)
// }

// func (s *Store) savePosts(path string)    { _ = writeJSONFile(path, s.posts) }
// func (s *Store) saveTags(path string)     { _ = writeJSONFile(path, s.tags) }
// func (s *Store) saveFriends(path string)  { _ = writeJSONFile(path, s.friends) }
// func (s *Store) saveProfiles(path string) { _ = writeJSONFile(path, s.profiles) }
// func (s *Store) saveLikes(path string)    { _ = writeJSONFile(path, s.postLikes) }

// //
// // ======== Posts ops ========
// //

// // decorateï¼šç”¨æœ€æ–°æš±ç¨±è¦†è“‹ä½œè€…åå­—ï¼Œä¸¦è¨ˆç®— LikeCount/LikedByMe
// func (s *Store) decorate(p Post, viewerUID string) Post {
// 	cp := p
// 	if cp.Author.ID != "" {
// 		cp.Author.Name = s.displayName(cp.Author.ID)
// 	}
// 	set := s.postLikes[cp.ID]
// 	cp.LikeCount = len(set)
// 	_, liked := set[viewerUID]
// 	cp.LikedByMe = liked
// 	return cp
// }

// func (s *Store) list(tab string, tags []string, viewerUID string) []Post {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()

// 	// ç¯©é¸
// 	var base []Post
// 	if len(tags) > 0 {
// 		tagset := map[string]struct{}{}
// 		for _, t := range tags {
// 			tagset[strings.ToLower(strings.TrimSpace(t))] = struct{}{}
// 		}
// 		for _, p := range s.posts {
// 			for _, pt := range p.Tags {
// 				if _, ok := tagset[strings.ToLower(pt)]; ok {
// 					base = append(base, p)
// 					break
// 				}
// 			}
// 		}
// 	} else {
// 		base = append(base, s.posts...)
// 	}

// 	// å¸¶å…¥ LikeCount / LikedByMe / æœ€æ–°æš±ç¨±
// 	out := make([]Post, 0, len(base))
// 	for _, p := range base {
// 		out = append(out, s.decorate(p, viewerUID))
// 	}

// 	// æ’åº
// 	if tab == "hot" {
// 		sort.Slice(out, func(i, j int) bool {
// 			if out[i].LikeCount == out[j].LikeCount {
// 				return out[i].CreatedAt > out[j].CreatedAt
// 			}
// 			return out[i].LikeCount > out[j].LikeCount
// 		})
// 	} else {
// 		sort.Slice(out, func(i, j int) bool { return out[i].CreatedAt > out[j].CreatedAt })
// 	}
// 	return out
// }

// func (s *Store) create(p Post) Post {
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	s.posts = append([]Post{p}, s.posts...)
// 	return p
// }

// func (s *Store) byID(id string) (Post, int) {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()
// 	for i, p := range s.posts {
// 		if p.ID == id {
// 			return p, i
// 		}
// 	}
// 	return Post{}, -1
// }

// func (s *Store) updateAt(i int, p Post) Post {
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	s.posts[i] = p
// 	return p
// }

// func (s *Store) deleteAt(i int) {
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	s.posts = append(s.posts[:i], s.posts[i+1:]...)
// }

// func (s *Store) userPosts(uid string, viewerUID string) []Post {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()
// 	var out []Post
// 	for _, p := range s.posts {
// 		if p.Author.ID == uid {
// 			out = append(out, s.decorate(p, viewerUID))
// 		}
// 	}
// 	sort.Slice(out, func(i, j int) bool { return out[i].CreatedAt > out[j].CreatedAt })
// 	return out
// }

// //
// // ======== Tags helpers ========
// //

// func normalizeTag(t string) string { return strings.TrimSpace(strings.ToLower(t)) }

// func (s *Store) getTags(uid string) []string {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()
// 	return append([]string(nil), s.tags[uid]...)
// }

// func (s *Store) addTag(uid, tag string) []string {
// 	t := normalizeTag(tag)
// 	if t == "" {
// 		return s.getTags(uid)
// 	}
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	cur := s.tags[uid]
// 	for _, x := range cur {
// 		if x == t {
// 			return append([]string(nil), cur...)
// 		}
// 	}
// 	cur = append(cur, t)
// 	s.tags[uid] = cur
// 	return append([]string(nil), cur...)
// }

// func (s *Store) removeTag(uid, tag string) []string {
// 	t := normalizeTag(tag)
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	cur := s.tags[uid]
// 	var out []string
// 	for _, x := range cur {
// 		if x != t {
// 			out = append(out, x)
// 		}
// 	}
// 	s.tags[uid] = out
// 	return append([]string(nil), out...)
// }

// //
// // ======== Friends helpers ========
// //

// func (s *Store) getFriends(uid string) []string {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()
// 	set := s.friends[uid]
// 	out := make([]string, 0, len(set))
// 	for id := range set {
// 		out = append(out, id)
// 	}
// 	sort.Strings(out)
// 	return out
// }

// func (s *Store) follow(uid, target string) {
// 	if uid == "" || target == "" || uid == target {
// 		return
// 	}
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	m := s.friends[uid]
// 	if m == nil {
// 		m = make(map[string]struct{})
// 		s.friends[uid] = m
// 	}
// 	m[target] = struct{}{}
// }

// func (s *Store) unfollow(uid, target string) {
// 	if uid == "" || target == "" {
// 		return
// 	}
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	m := s.friends[uid]
// 	if m == nil {
// 		return
// 	}
// 	delete(m, target)
// }

// //
// // ======== Profiles helpers ========
// //

// func (s *Store) getProfile(uid string) (Profile, bool) {
// 	s.mu.RLock()
// 	defer s.mu.RUnlock()
// 	p, ok := s.profiles[uid]
// 	return p, ok
// }

// func (s *Store) upsertProfile(p Profile) Profile {
// 	s.mu.Lock()
// 	defer s.mu.Unlock()
// 	if p.ID == "" {
// 		return p
// 	}
// 	ex, ok := s.profiles[p.ID]
// 	if !ok {
// 		s.profiles[p.ID] = p
// 		return p
// 	}
// 	if p.Name != "" {
// 		ex.Name = p.Name
// 	}
// 	if p.Nickname != nil {
// 		ex.Nickname = p.Nickname
// 	}
// 	if p.AvatarURL != nil {
// 		ex.AvatarURL = p.AvatarURL
// 	}
// 	if p.Instagram != nil {
// 		ex.Instagram = p.Instagram
// 	}
// 	if p.Facebook != nil {
// 		ex.Facebook = p.Facebook
// 	}
// 	if p.LineId != nil {
// 		ex.LineId = p.LineId
// 	}
// 	ex.ShowInstagram = p.ShowInstagram
// 	ex.ShowFacebook = p.ShowFacebook
// 	ex.ShowLine = p.ShowLine

// 	s.profiles[p.ID] = ex
// 	return ex
// }

// func (s *Store) displayName(uid string) string {
// 	if p, ok := s.getProfile(uid); ok {
// 		if p.Nickname != nil && *p.Nickname != "" {
// 			return *p.Nickname
// 		}
// 		if p.Name != "" {
// 			return p.Name
// 		}
// 	}
// 	return uid
// }

// //
// // ======== Auth & App context ========
// //

// type AppCtx struct {
// 	Store      *Store
// 	AuthClient *auth.Client
// }

// type ctxKey string

// const uidKey ctxKey = "uid"

// func currentUID(r *http.Request) string {
// 	if v := r.Context().Value(uidKey); v != nil {
// 		if s, ok := v.(string); ok {
// 			return s
// 		}
// 	}
// 	return ""
// }

// // æ”¯æ´ä¸‰ç¨®æ¨¡å¼ï¼š
// // 1) æ­£å¼æ†‘è­‰ï¼šFIREBASE_PROJECT_ID + GOOGLE_APPLICATION_CREDENTIALS æˆ– FIREBASE_SERVICE_ACCOUNT_JSON
// // 2) Emulatorï¼šFIREBASE_PROJECT_ID + FIREBASE_AUTH_EMULATOR_HOST
// // 3) å…é©—è­‰ï¼šNO_AUTH=1ï¼ˆä¸åˆå§‹ Firebaseï¼Œç”¨æ–¼æœ¬æ©Ÿæˆ–æš«æ¸¬ï¼‰
// var noAuth = os.Getenv("NO_AUTH") == "1"

// func newAuthClient() *auth.Client {
// 	if noAuth {
// 		return nil // ä¸éœ€è¦ Firebase
// 	}

// 	proj := os.Getenv("FIREBASE_PROJECT_ID")
// 	if proj == "" {
// 		log.Fatal("FIREBASE_PROJECT_ID not set")
// 	}

// 	var opts []option.ClientOption
// 	// é¦–é¸ï¼šJSON ç›´æ¥æ”¾åœ¨ç’°å¢ƒè®Šæ•¸ï¼ˆæœ€é©åˆ Render Secretsï¼‰
// 	if saJSON := os.Getenv("FIREBASE_SERVICE_ACCOUNT_JSON"); saJSON != "" {
// 		opts = append(opts, option.WithCredentialsJSON([]byte(saJSON)))
// 	} else if cred := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS"); cred != "" {
// 		if _, err := os.Stat(cred); err != nil {
// 			log.Fatalf("GOOGLE_APPLICATION_CREDENTIALS %q not readable: %v", cred, err)
// 		}
// 		opts = append(opts, option.WithCredentialsFile(cred))
// 	} else if os.Getenv("FIREBASE_AUTH_EMULATOR_HOST") == "" {
// 		log.Fatal("Missing credentials: set FIREBASE_SERVICE_ACCOUNT_JSON or GOOGLE_APPLICATION_CREDENTIALS (or use FIREBASE_AUTH_EMULATOR_HOST / NO_AUTH=1)")
// 	}

// 	app, err := firebase.NewApp(context.Background(), &firebase.Config{
// 		ProjectID: proj,
// 	}, opts...)
// 	if err != nil {
// 		log.Fatalf("firebase init: %v", err)
// 	}
// 	c, err := app.Auth(context.Background())
// 	if err != nil {
// 		log.Fatalf("firebase auth: %v", err)
// 	}
// 	return c
// }

// func withAuth(app *AppCtx, next http.HandlerFunc) http.HandlerFunc {
// 	return func(w http.ResponseWriter, r *http.Request) {
// 		if noAuth {
// 			// å…é©—è­‰æ¨¡å¼ï¼šå…è¨±ç”¨ Authorization: Debug <uid> æŒ‡å®šèº«åˆ†ï¼Œé è¨­ u_me
// 			uid := "u_me"
// 			if h := r.Header.Get("Authorization"); strings.HasPrefix(h, "Debug ") {
// 				uid = strings.TrimSpace(strings.TrimPrefix(h, "Debug "))
// 			}
// 			ctx := context.WithValue(r.Context(), uidKey, uid)
// 			next(w, r.WithContext(ctx))
// 			return
// 		}

// 		authz := r.Header.Get("Authorization")
// 		if !strings.HasPrefix(authz, "Bearer ") {
// 			http.Error(w, "missing bearer token", http.StatusUnauthorized)
// 			return
// 		}
// 		idToken := strings.TrimSpace(strings.TrimPrefix(authz, "Bearer "))
// 		token, err := app.AuthClient.VerifyIDToken(r.Context(), idToken)
// 		if err != nil {
// 			http.Error(w, "invalid token: "+err.Error(), http.StatusUnauthorized)
// 			return
// 		}
// 		ctx := context.WithValue(r.Context(), uidKey, token.UID)
// 		next(w, r.WithContext(ctx))
// 	}
// }

// // éå¼·åˆ¶é©—è­‰ï¼šè‹¥å¸¶ token å‰‡è§£æ viewerUIDï¼›å…é©—è­‰æ¨¡å¼å…è¨± Debug <uid>
// func tryViewerUID(app *AppCtx, r *http.Request) string {
// 	if noAuth {
// 		if h := r.Header.Get("Authorization"); strings.HasPrefix(h, "Debug ") {
// 			return strings.TrimSpace(strings.TrimPrefix(h, "Debug "))
// 		}
// 		return ""
// 	}
// 	authz := r.Header.Get("Authorization")
// 	if strings.HasPrefix(authz, "Bearer ") {
// 		idToken := strings.TrimSpace(strings.TrimPrefix(authz, "Bearer "))
// 		if tok, err := app.AuthClient.VerifyIDToken(r.Context(), idToken); err == nil {
// 			return tok.UID
// 		}
// 	}
// 	return ""
// }

// //
// // ======== main ========
// //

// func main() {
// 	// Render å»ºè­°æŠŠ Persistent Disk æ›åˆ°æŒ‡å®šè·¯å¾‘ï¼Œä¸¦ä»¥ DATA_DIR æŒ‡å‘ï¼›å¦å‰‡é è¨­ /dataï¼Œè‹¥ç„¡æ³•å¯«å…¥å¯æ”¹ç”¨ os.TempDir()
// 	dataDir := os.Getenv("DATA_DIR")
// 	if dataDir == "" {
// 		// è‹¥åœ¨ Render æ²’æ›ç£ç¢Ÿï¼Œ/data å¯èƒ½ä¸å­˜åœ¨ï¼›å‚™æ´ç”¨å°ˆæ¡ˆè·¯å¾‘æˆ–è‡¨æ™‚è·¯å¾‘
// 		dataDir = "/data"
// 		if _, err := os.Stat(dataDir); err != nil {
// 			dataDir = filepath.Join(".", "data")
// 		}
// 	}
// 	uploadsDir := filepath.Join(dataDir, "uploads")
// 	postsFile := filepath.Join(dataDir, "posts.json")
// 	tagsFile := filepath.Join(dataDir, "tags.json")
// 	friendsFile := filepath.Join(dataDir, "friends.json")
// 	profilesFile := filepath.Join(dataDir, "profiles.json")
// 	likesFile := filepath.Join(dataDir, "likes.json")

// 	ensureDir(dataDir)
// 	ensureDir(uploadsDir)

// 	store := &Store{
// 		tags:      map[string][]string{},
// 		friends:   map[string]map[string]struct{}{},
// 		profiles:  map[string]Profile{},
// 		postLikes: map[string]map[string]struct{}{},
// 	}
// 	store.loadAll(postsFile, tagsFile, friendsFile, profilesFile, likesFile)

// 	// Demo è³‡æ–™ï¼ˆé¦–æ¬¡å•Ÿå‹•ï¼‰
// 	func() {
// 		store.mu.RLock()
// 		emptyPosts := len(store.posts) == 0
// 		_, hasMe := store.profiles["u_me"]
// 		_, hasBob := store.profiles["u_bob"]
// 		store.mu.RUnlock()

// 		if emptyPosts {
// 			store.create(Post{
// 				ID:        "p1",
// 				Author:    User{ID: "u_bob", Name: "Bob"},
// 				Text:      "ä»Šå¤©æŠŠ UI å¡ç‰‡é‚Šè§’ä¿®å¥½äº† âœ…",
// 				CreatedAt: nowISO(),
// 				LikeCount: 0,
// 				LikedByMe: false,
// 				Comments:  []Comment{},
// 				Tags:      []string{"flutter", "design"},
// 			})
// 			store.create(Post{
// 				ID:        "p2",
// 				Author:    User{ID: "u_me", Name: "Me"},
// 				Text:      "å—¨ï¼é€™æ˜¯æˆ‘çš„ç¬¬ä¸€ç¯‡ ğŸ™‚",
// 				CreatedAt: nowISO(),
// 				LikeCount: 0,
// 				LikedByMe: false,
// 				Comments:  []Comment{},
// 				Tags:      []string{"hello"},
// 			})
// 			store.savePosts(postsFile)
// 		}
// 		if !hasMe {
// 			nick := "Me"
// 			store.upsertProfile(Profile{ID: "u_me", Name: "Me", Nickname: &nick})
// 		}
// 		if !hasBob {
// 			nick := "Bob"
// 			insta := "@bob_dev"
// 			store.upsertProfile(Profile{
// 				ID:            "u_bob",
// 				Name:          "Bob",
// 				Nickname:      &nick,
// 				Instagram:     &insta,
// 				ShowInstagram: true,
// 			})
// 		}
// 	}()

// 	app := &AppCtx{Store: store, AuthClient: newAuthClient()}

// 	mux := http.NewServeMux()

// 	// å¥åº·æª¢æŸ¥ï¼ˆRender Health Check å¯ç”¨ï¼‰
// 	mux.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) {
// 		w.WriteHeader(http.StatusOK)
// 		_, _ = w.Write([]byte("ok"))
// 	})

// 	// CORS
// 	cors := func(next http.Handler) http.Handler {
// 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
// 			w.Header().Set("Access-Control-Allow-Origin", "*")
// 			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
// 			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
// 			if r.Method == http.MethodOptions {
// 				w.WriteHeader(http.StatusNoContent)
// 				return
// 			}
// 			next.ServeHTTP(w, r)
// 		})
// 	}

// 	// éœæ…‹ï¼š/uploads/*
// 	mux.Handle("/uploads/", http.StripPrefix("/uploads/", http.FileServer(http.Dir(uploadsDir))))

// 	// ä¸Šå‚³ï¼šPOST /uploadï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/upload", withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 		if r.Method == http.MethodOptions {
// 			w.WriteHeader(http.StatusNoContent)
// 			return
// 		}
// 		if r.Method != http.MethodPost {
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 			return
// 		}
// 		r.Body = http.MaxBytesReader(w, r.Body, 20<<20) // 20MB
// 		if err := r.ParseMultipartForm(25 << 20); err != nil {
// 			http.Error(w, "parse form: "+err.Error(), http.StatusBadRequest)
// 			return
// 		}
// 		file, hdr, err := r.FormFile("file")
// 		if err != nil {
// 			http.Error(w, "form file: "+err.Error(), http.StatusBadRequest)
// 			return
// 		}
// 		defer file.Close()

// 		head := make([]byte, 512)
// 		n, _ := io.ReadFull(file, head)
// 		head = head[:n]
// 		mtype := http.DetectContentType(head)

// 		ext := ""
// 		switch mtype {
// 		case "image/jpeg":
// 			ext = ".jpg"
// 		case "image/png":
// 			ext = ".png"
// 		case "image/webp":
// 			ext = ".webp"
// 		case "image/gif":
// 			ext = ".gif"
// 		default:
// 			if e := strings.ToLower(filepath.Ext(hdr.Filename)); map[string]bool{
// 				".jpg": true, ".jpeg": true, ".png": true, ".webp": true, ".gif": true,
// 			}[e] {
// 				ext = e
// 			}
// 			if ext == "" {
// 				http.Error(w, "unsupported image type: "+mtype, http.StatusBadRequest)
// 				return
// 			}
// 		}

// 		ts := time.Now().Format("20060102T150405.000")
// 		base := strings.TrimSuffix(hdr.Filename, filepath.Ext(hdr.Filename))
// 		if base == "" {
// 			base = "img"
// 		}
// 		base = strings.Map(func(r rune) rune {
// 			if r == '-' || r == '_' || r == '.' || r == ' ' ||
// 				(r >= '0' && r <= '9') || (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') {
// 				return r
// 			}
// 			return '-'
// 		}, base)
// 		filename := ts + "_" + base + ext
// 		dst := filepath.Join(uploadsDir, filename)

// 		out, err := os.Create(dst)
// 		if err != nil {
// 			http.Error(w, "create file: "+err.Error(), http.StatusInternalServerError)
// 			return
// 		}
// 		defer out.Close()
// 		if _, err := out.Write(head); err != nil {
// 			http.Error(w, "write head: "+err.Error(), http.StatusInternalServerError)
// 			return
// 		}
// 		if _, err := io.Copy(out, file); err != nil {
// 			http.Error(w, "write file: "+err.Error(), http.StatusInternalServerError)
// 			return
// 		}

// 		if ctype := mime.TypeByExtension(ext); ctype != "" {
// 			w.Header().Set("Content-Type", "application/json; charset=utf-8")
// 		}
// 		writeJSON(w, http.StatusOK, map[string]string{"url": "/uploads/" + filename})
// 	}))

// 	// /postsï¼šGETï¼ˆå¯åŒ¿åï¼Œè‹¥å¸¶ token è¨ˆç®— LikedByMeï¼‰ï¼ŒPOSTï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/posts", func(w http.ResponseWriter, r *http.Request) {
// 		switch r.Method {
// 		case http.MethodGet:
// 			viewer := tryViewerUID(app, r)
// 			tab := r.URL.Query().Get("tab")
// 			var tags []string
// 			if t := r.URL.Query().Get("tags"); t != "" {
// 				tags = strings.Split(t, ",")
// 			}
// 			writeJSON(w, http.StatusOK, store.list(tab, tags, viewer))

// 		case http.MethodPost:
// 			withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 				var req struct {
// 					Text     string   `json:"text"`
// 					Tags     []string `json:"tags"`
// 					ImageURL *string  `json:"imageUrl,omitempty"`
// 				}
// 				if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 					http.Error(w, err.Error(), http.StatusBadRequest)
// 					return
// 				}
// 				uid := currentUID(r)
// 				p := Post{
// 					ID:        time.Now().Format("20060102T150405.000000000"),
// 					Author:    User{ID: uid, Name: store.displayName(uid)},
// 					Text:      req.Text,
// 					CreatedAt: nowISO(),
// 					LikeCount: 0,
// 					LikedByMe: false,
// 					Comments:  []Comment{},
// 					Tags:      req.Tags,
// 					ImageURL:  req.ImageURL,
// 				}
// 				created := store.create(p)
// 				store.savePosts(postsFile)
// 				writeJSON(w, http.StatusOK, store.decorate(created, uid)) // â˜… decorate
// 			})(w, r)

// 		default:
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 		}
// 	})

// 	// /posts/{id}, /posts/{id}/like, /posts/{id}/comments
// 	mux.HandleFunc("/posts/", func(w http.ResponseWriter, r *http.Request) {
// 		path := strings.TrimPrefix(r.URL.Path, "/posts/")
// 		if path == "" {
// 			http.NotFound(w, r)
// 			return
// 		}
// 		parts := strings.Split(path, "/")
// 		id := parts[0]

// 		if len(parts) == 1 {
// 			switch r.Method {
// 			case http.MethodPut:
// 				withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 					var req struct {
// 						Text     string   `json:"text"`
// 						Tags     []string `json:"tags"`
// 						ImageURL *string  `json:"imageUrl,omitempty"`
// 					}
// 					if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 						http.Error(w, err.Error(), http.StatusBadRequest)
// 						return
// 					}
// 					p, idx := store.byID(id)
// 					if idx < 0 {
// 						http.Error(w, "not found", http.StatusNotFound)
// 						return
// 					}
// 					if currentUID(r) != p.Author.ID {
// 						http.Error(w, "forbidden", http.StatusForbidden)
// 						return
// 					}
// 					p.Text, p.Tags, p.ImageURL = req.Text, req.Tags, req.ImageURL
// 					updated := store.updateAt(idx, p)
// 					store.savePosts(postsFile)
// 					writeJSON(w, http.StatusOK, store.decorate(updated, currentUID(r))) // â˜…
// 				})(w, r)

// 			case http.MethodDelete:
// 				withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 					p, idx := store.byID(id)
// 					if idx < 0 {
// 						http.Error(w, "not found", http.StatusNotFound)
// 						return
// 					}
// 					if currentUID(r) != p.Author.ID {
// 						http.Error(w, "forbidden", http.StatusForbidden)
// 						return
// 					}
// 					if p.ImageURL != nil && strings.HasPrefix(*p.ImageURL, "/uploads/") {
// 						_ = os.Remove(filepath.Join(uploadsDir, filepath.Base(*p.ImageURL)))
// 					}
// 					store.deleteAt(idx)
// 					store.savePosts(postsFile)
// 					writeJSON(w, http.StatusOK, map[string]bool{"ok": true})
// 				})(w, r)

// 			default:
// 				http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 			}
// 			return
// 		}

// 		switch parts[1] {
// 		case "like":
// 			withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 				if r.Method != http.MethodPost {
// 					http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 					return
// 				}
// 				uid := currentUID(r)
// 				p, idx := store.byID(id)
// 				if idx < 0 {
// 					http.Error(w, "not found", http.StatusNotFound)
// 					return
// 				}

// 				store.mu.Lock()
// 				set := store.postLikes[p.ID]
// 				if set == nil {
// 					set = make(map[string]struct{})
// 				}
// 				if _, ok := set[uid]; ok {
// 					delete(set, uid)
// 				} else {
// 					set[uid] = struct{}{}
// 				}
// 				store.postLikes[p.ID] = set
// 				// æ›´æ–°å›å‚³æ¬„ä½
// 				p.LikeCount = len(set)
// 				_, liked := set[uid]
// 				p.LikedByMe = liked
// 				store.posts[idx] = p
// 				store.mu.Unlock()

// 				store.saveLikes(likesFile)
// 				writeJSON(w, http.StatusOK, store.decorate(p, uid)) // â˜…
// 			})(w, r)

// 		case "comments":
// 			withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 				if r.Method != http.MethodPost {
// 					http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 					return
// 				}
// 				var req struct {
// 					Text string `json:"text"`
// 				}
// 				if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 					http.Error(w, err.Error(), http.StatusBadRequest)
// 					return
// 				}
// 				uid := currentUID(r)
// 				p, idx := store.byID(id)
// 				if idx < 0 {
// 					http.Error(w, "not found", http.StatusNotFound)
// 					return
// 				}
// 				p.Comments = append(p.Comments, Comment{
// 					ID:        time.Now().Format("20060102T150405.000000000"),
// 					Author:    User{ID: uid, Name: store.displayName(uid)},
// 					Text:      req.Text,
// 					CreatedAt: nowISO(),
// 				})
// 				updated := store.updateAt(idx, p)
// 				store.savePosts(postsFile)
// 				writeJSON(w, http.StatusOK, store.decorate(updated, uid)) // â˜…
// 			})(w, r)

// 		default:
// 			http.NotFound(w, r)
// 		}
// 	})

// 	// /meï¼šGET è®€è‡ªå·±çš„ Profileã€PATCH æ›´æ–°ï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/me", withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 		uid := currentUID(r)
// 		switch r.Method {
// 		case http.MethodGet:
// 			if p, ok := store.getProfile(uid); ok {
// 				writeJSON(w, http.StatusOK, p)
// 				return
// 			}
// 			writeJSON(w, http.StatusOK, Profile{ID: uid, Name: uid})
// 		case http.MethodPatch:
// 			var p Profile
// 			if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
// 				http.Error(w, err.Error(), http.StatusBadRequest)
// 				return
// 			}
// 			p.ID = uid // å¼·åˆ¶ä»¥ token å…§çš„ uid ç‚ºæº–
// 			updated := store.upsertProfile(p)
// 			store.saveProfiles(profilesFile)
// 			writeJSON(w, http.StatusOK, updated)
// 		default:
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 		}
// 	}))

// 	// /me/tagsï¼šGET/POSTï¼Œ/me/tags/{tag}ï¼šDELETEï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/me/tags", withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 		if r.URL.Path != "/me/tags" {
// 			http.NotFound(w, r)
// 			return
// 		}
// 		uid := currentUID(r)
// 		switch r.Method {
// 		case http.MethodGet:
// 			writeJSON(w, http.StatusOK, store.getTags(uid))
// 		case http.MethodPost:
// 			var body struct {
// 				Tag string `json:"tag"`
// 			}
// 			if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
// 				http.Error(w, err.Error(), http.StatusBadRequest)
// 				return
// 			}
// 			tags := store.addTag(uid, body.Tag)
// 			store.saveTags(tagsFile)
// 			writeJSON(w, http.StatusOK, tags)
// 		default:
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 		}
// 	}))
// 	mux.HandleFunc("/me/tags/", withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 		if r.Method != http.MethodDelete {
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 			return
// 		}
// 		uid := currentUID(r)
// 		tag := strings.TrimPrefix(r.URL.Path, "/me/tags/")
// 		if tag == "" {
// 			http.NotFound(w, r)
// 			return
// 		}
// 		tags := store.removeTag(uid, tag)
// 		store.saveTags(tagsFile)
// 		writeJSON(w, http.StatusOK, tags)
// 	}))

// 	// /me/friendsï¼šGET æˆ‘çš„å¥½å‹ ID åˆ—è¡¨ï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/me/friends", withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 		if r.Method != http.MethodGet {
// 			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 			return
// 		}
// 		uid := currentUID(r)
// 		writeJSON(w, http.StatusOK, store.getFriends(uid))
// 	}))

// 	// /users/{id}ï¼ˆå…¬é–‹ï¼‰ã€/users/{id}/postsï¼ˆå…¬é–‹ï¼‰ã€/users/{id}/followï¼ˆéœ€ç™»å…¥ï¼‰
// 	mux.HandleFunc("/users/", func(w http.ResponseWriter, r *http.Request) {
// 		rest := strings.TrimPrefix(r.URL.Path, "/users/")
// 		if rest == "" {
// 			http.NotFound(w, r)
// 			return
// 		}
// 		parts := strings.Split(rest, "/")
// 		userId := parts[0]

// 		if len(parts) == 1 {
// 			// GET /users/{id}
// 			if r.Method != http.MethodGet {
// 				http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 				return
// 			}
// 			if p, ok := store.getProfile(userId); ok {
// 				writeJSON(w, http.StatusOK, p)
// 				return
// 			}
// 			writeJSON(w, http.StatusOK, Profile{ID: userId, Name: userId})
// 			return
// 		}

// 		switch parts[1] {
// 		case "follow":
// 			withAuth(app, func(w http.ResponseWriter, r *http.Request) {
// 				uid := currentUID(r)
// 				switch r.Method {
// 				case http.MethodPost:
// 					store.follow(uid, userId)
// 					store.saveFriends(friendsFile)
// 					w.WriteHeader(http.StatusNoContent)
// 				case http.MethodDelete:
// 					store.unfollow(uid, userId)
// 					store.saveFriends(friendsFile)
// 					w.WriteHeader(http.StatusNoContent)
// 				default:
// 					http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 				}
// 			})(w, r)
// 		case "posts":
// 			// GET /users/{id}/postsï¼ˆå¯åŒ¿åï¼Œè‹¥å¸¶ token è¨ˆç®— LikedByMeï¼‰
// 			if r.Method != http.MethodGet {
// 				http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
// 				return
// 			}
// 			viewer := tryViewerUID(app, r)
// 			writeJSON(w, http.StatusOK, store.userPosts(userId, viewer))
// 		default:
// 			http.NotFound(w, r)
// 		}
// 	})

// 	// Start
// 	port := os.Getenv("PORT") // Render æœƒæ³¨å…¥ PORT
// 	if port == "" {
// 		port = "8088"
// 	}
// 	addr := ":" + port
// 	log.Println("Server listening on", addr, "DATA_DIR=", dataDir, "NO_AUTH=", noAuth)
// 	if err := http.ListenAndServe(addr, cors(mux)); err != nil {
// 		log.Fatal(err)
// 	}
// }
